var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jieko","category":"page"},{"location":"#Jieko","page":"Home","title":"Jieko","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jieko.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Jieko]","category":"page"},{"location":"#Jieko.Jieko","page":"Home","title":"Jieko.Jieko","text":"Prelude\n\nContains Jieko.Prelude, all public definitions can be imported by using Jieko.Prelude.\n\nDefinitions\n\nConstants\n\nDEFLIST\n\nDEF\n\nMacros\n\n@prelude_module\n\n@pub <definition>\n\nStructs\n\nstruct NotImplementedError <: Exception\n\nInterfaces\n\nstub(mod::Module) -> JiekoStub\n\nnot_implemented_error()\n\n\n\n\n\n","category":"module"},{"location":"#Jieko.DEF","page":"Home","title":"Jieko.DEF","text":"DEF\n\nSimilar to SIGNATURES but has more precise method/struct information obtained directly from the @pub macro.\n\n\n\n\n\n","category":"constant"},{"location":"#Jieko.DEFLIST","page":"Home","title":"Jieko.DEFLIST","text":"DEFLIST\n\nList all the @pub definitions of a module. It shows nothing if the binded object is not a module.\n\n\n\n\n\n","category":"constant"},{"location":"#Jieko.not_implemented_error-Tuple{}","page":"Home","title":"Jieko.not_implemented_error","text":"Raise a NotImplementedError exception. This is useful to mark an interface method as not implemented yet.\n\n\n\n\n\n","category":"method"},{"location":"#Jieko.stub-Tuple{Module}","page":"Home","title":"Jieko.stub","text":"stub(mod::Module) -> JiekoStub\n\nReturn the interface stub storage for a module.\n\n\n\n\n\n","category":"method"},{"location":"#Jieko.@prelude_module-Tuple{}","page":"Home","title":"Jieko.@prelude_module","text":"@prelude_module\n\nWrap all interfaces from the module in which this macro is called in a Prelude module and export them. This is useful for exporting all interfaces from a module to be used in other modules.\n\nOptionally, you can pass a list of extra symbols to be exported along with the interfaces.\n\nThe concept of Prelude is borrowed from rust, where it is used to give users an explicit way to import all the symbols from a package. This is useful for the package authors to provide a default set of symbols to be used by the users via using MyPackage.Prelude without giving them the easy way of importing everything from the package via using MyPackage.\n\nBecause Prelude module only contains the API symbols, it makes it easier for the toolchain to check the APIs without mixing them with the implementation details.\n\nExample\n\nmodule MyModule\nusing Jieko.Prelude # load everything you need from Jieko\n\n@interface foo(x::Float64)::Int = 2\n\n# export interface `foo` and some extra symbols\n@prelude_module\n\nend\n\n\n\n\n\n","category":"macro"},{"location":"#Jieko.@pub-Tuple{Any}","page":"Home","title":"Jieko.@pub","text":"@pub <definition>\n\nMark a definition as public. This will help the toolchain generating docstring and other things.\n\nIf definition is a function. It will be treated as an interface definition as overloaded function cannot be denoted by public.\n\n\n\n\n\n","category":"macro"}]
}
