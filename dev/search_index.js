var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jieko","category":"page"},{"location":"#Jieko","page":"Home","title":"Jieko","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jieko.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Jieko]","category":"page"},{"location":"#Jieko.INTERFACE","page":"Home","title":"Jieko.INTERFACE","text":"const INTERFACE = InterfaceSignature()\n\nSimilar to SIGNATURES but has more precise method information obtained directly from the @interface macro.\n\n\n\n\n\n","category":"constant"},{"location":"#Jieko.INTERFACE_LIST","page":"Home","title":"Jieko.INTERFACE_LIST","text":"const INTERFACE_LIST = InterfaceList()\n\nList all the interface methods of a module. It shows nothing if the binded object is not a module.\n\n\n\n\n\n","category":"constant"},{"location":"#Jieko.InterfaceMethod","page":"Home","title":"Jieko.InterfaceMethod","text":"struct InterfaceMethod\n\nThe signature information of an interface method.\n\nnote: Note\nThis is only used for printing for now. Thus we do not store the actual type signature at the moment. We should think about how to store the type signature and use this info in the future.\n\n\n\n\n\n","category":"type"},{"location":"#Jieko.TypeAnnotation","page":"Home","title":"Jieko.TypeAnnotation","text":"struct TypeAnnotation\n\nThe annotation information of a type. This also stores the name user typed in the annotation, e.g an alias of type is used instead of the original type name. This is useful for printing the type annotation in docstrings.\n\n\n\n\n\n","category":"type"},{"location":"#Jieko.WhereParam","page":"Home","title":"Jieko.WhereParam","text":"struct WhereParam\n\nThe type variable information of a function.\n\n\n\n\n\n","category":"type"},{"location":"#Jieko.interfaces-Tuple{Module}","page":"Home","title":"Jieko.interfaces","text":"public Jieko.interfaces(mod::Module)\n\nReturn the interface stub storage for a module.\n\n\n\n\n\n","category":"method"},{"location":"#Jieko.@export_all_interfaces-Tuple{}","page":"Home","title":"Jieko.@export_all_interfaces","text":"@export_all_interfaces <begin ... end>\n\nWrap all interfaces from the module in which this macro is called in a Prelude module and export them. This is useful for exporting all interfaces from a module to be used in other modules.\n\nOptionally, you can pass a list of extra symbols to be exported along with the interfaces.\n\nThe concept of Prelude is borrowed from rust, where it is used to give users an explicit way to import all the symbols from a package. This is useful for the package authors to provide a default set of symbols to be used by the users via using MyPackage.Prelude without giving them the easy way of importing everything from the package via using MyPackage.\n\nBecause Prelude module only contains the API symbols, it makes it easier for the toolchain to check the APIs without mixing them with the implementation details.\n\nExample\n\nmodule MyModule\nusing Jieko.Prelude # load everything you need from Jieko\n\n@interface foo(x::Float64)::Int = 2\n\n# export interface `foo` and some extra symbols\n@export_all_interfaces begin\n    @interface\n    @export_all_interfaces\n    INTERFACE\n    INTERFACE_LIST\n    not_implemented_error\nend\nend\n\n\n\n\n\n","category":"macro"},{"location":"#Jieko.@interface-Tuple{Any}","page":"Home","title":"Jieko.@interface","text":"@interface <function definition>\n\nMark a method definition as interface. This will help the toolchain generating docstring and other things. The interface method is usually the most generic one that errors.\n\n\n\n\n\n","category":"macro"}]
}
